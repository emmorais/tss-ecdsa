// Copyright (c) Facebook, Inc. and its affiliates.
// Modifications Copyright (c) 2022-2023 Bolt Labs Holdings, Inc
//
// This source code is licensed under both the MIT license found in the
// LICENSE-MIT file in the root directory of this source tree and the Apache
// License, Version 2.0 found in the LICENSE-APACHE file in the root directory
// of this source tree.

//! The primary public API for executing the threshold signing protocol.
//!
//! This module includes the main [`Participant`] driver.

use crate::{
    curve::CurveTrait,
    errors::{CallerError, InternalError, Result},
    messages::{Message, MessageType},
    participant::{InnerProtocolParticipant, ProtocolParticipant, Status},
    protocol::participant_config::ParticipantConfig,
    zkp::ProofContext,
};
use libpaillier::unknown_order::BigNumber;
use rand::{CryptoRng, Rng, RngCore};
use serde::{Deserialize, Serialize};
use std::{
    cmp::{Ord, PartialOrd},
    collections::HashSet,
    fmt::{Debug, Formatter},
};
use tracing::{error, info, instrument, trace};

/// The set of subprotocols that a [`Participant`] can execute.
///
/// Note: An external user will never explicitly instantiate a `Broadcast`
/// participant; this type is created internally to the library.
#[derive(Debug)]
pub enum ProtocolType {
    Keygen,
    Tshare,
    Keyrefresh,
    AuxInfo,
    Presign,
    Broadcast,
    Sign,
    InteractiveSign,
}

/// The driver for a party executing a sub-protocol of the threshold signing
/// protocol.
///
/// A given [`Participant`] participates in an execution of one of several
/// sub-protocols required for threshold signing. The core functionality of
/// [`Participant`] is captured in the
/// [`process_single_message`](Participant::process_single_message) method: it
/// takes as input a [`Message`] and outputs a tuple containing the
/// participant's output alongside a list of messages to process.
///
/// # 🔒 Message handling
/// The calling application is responsible for receiving, sending and routing
/// all messages generated by participants of a sub-protocol session.
/// for its [`Participant`]. This includes:
/// 1. Initializing a session by calling [`Participant::initialize_message()`].
///    The message returned from that function must be passed back to the
/// [`Participant`] in order to begin the protocol execution.
/// 2. Receiving messages sent by other participants, and passing
/// them to the participant by calling
/// [`process_single_message()`](Participant::process_single_message()).
/// 3. Sending all messages generated
/// by [`process_single_message()`](Participant::process_single_message()) to
/// the correct recipient.
///
/// [`Message`]s contain a `to: ParticipantIdentifier` field which specifies the
/// recipient of a message. The calling application is responsible for
/// maintaining a mapping from [`ParticipantIdentifier`]s to some network
/// metadata so outgoing messages can be routed to the correct `Participant`.
///
/// The calling application can pass messages for a [`Participant`] as soon as
/// it receives them. The library handles messages received "too early" -- that
/// is, before a `Participant` has completed the prerequisite rounds -- by
/// storing them in memory. Stored messages are retrieved automatically and
/// processed at the appropriate point in the protocol, when all prerequisites
/// have been satisfied.
///
/// # 🔒 Storage requirements
/// It is up to the calling application to persist outputs used by the
/// participant. In addition, some of the outputs are private to the
/// participant, and **these must be stored securely by the calling
/// application**. Which outputs require secure storage is documented by each
/// protocol type, under the "Storage requirements" heading:
/// [`KeygenParticipant`](crate::keygen::KeygenParticipant),
/// [`AuxInfoParticipant`](crate::auxinfo::AuxInfoParticipant), and
/// [`PresignParticipant`](crate::PresignParticipant). In addition, some outputs
/// must only be used once and then discarded. These are documented as necessary
/// under the "Lifetime requirements" heading in the aforementioned types.
///
/// ## Requirements of external storage
/// Any external storage must be able to achieve the following requirements:
/// - Encryption: Data is stored encrypted.
/// - Freshness: The storage contains the most recent state of the execution and
///   avoids replay attacks.
/// - Secure deletion: Data can be securely deleted from storage.
#[derive(Debug)]
pub struct Participant<P>
where
    P: ProtocolParticipant,
{
    /// An identifier for this participant.
    id: ParticipantIdentifier,

    /// The [`ProtocolParticipant`] driver defining the actual protocol
    /// execution.
    participant: P,
}

impl<P: ProtocolParticipant> Participant<P> {
    /// Initialize the participant from a [`ParticipantConfig`].
    pub fn from_config(
        config: ParticipantConfig,
        sid: Identifier,
        input: P::Input,
    ) -> Result<Self> {
        info!("Initializing participant from config.");

        let (id, other_ids) = config.into_parts();

        Ok(Participant {
            id,
            participant: P::new(sid, id, other_ids, input)?,
        })
    }

    /// Retrieve the [`ParticipantIdentifier`] for this `Participant`.
    pub fn id(&self) -> ParticipantIdentifier {
        self.id
    }

    /// Retrieve the unique session [`Identifier`] for this `Participant`.
    pub fn sid(&self) -> Identifier {
        self.participant.sid()
    }

    /// Process the first message from the participant's inbox.
    ///
    /// ## Return type
    /// This returns a possible output and a set of messages:
    /// - The output holds the output of the protocol with the given session ID,
    ///   if it terminated for this participant.
    /// - The messages are a (possibly empty) list of messages to be sent out to
    ///   other participants.
    #[cfg_attr(feature = "flame_it", flame)]
    #[instrument(skip_all, err(Debug))]
    pub fn process_single_message<R: RngCore + CryptoRng>(
        &mut self,
        message: &Message,
        rng: &mut R,
    ) -> Result<(Option<P::Output>, Vec<Message>)> {
        info!("Processing single message.");

        // Check SID
        if message.id() != self.sid() {
            error!(
                "Message for session {} was routed to the wrong participant (sid: {})!",
                message.id(),
                self.sid()
            );
            Err(CallerError::WrongSessionId)?
        }

        // Check that message belongs to correct protocol
        match (message.message_type(), P::protocol_type()) {
            (MessageType::Auxinfo(_), ProtocolType::AuxInfo)
            | (MessageType::Keygen(_), ProtocolType::Keygen)
            | (MessageType::Tshare(_), ProtocolType::Tshare)
            | (MessageType::Keyrefresh(_), ProtocolType::Keyrefresh)
            | (MessageType::Presign(_), ProtocolType::Presign)
            | (MessageType::Sign(_), ProtocolType::Sign)
            // Interactive sign runs presign and sign in sequence, so we allow both message types
            | (MessageType::Presign(_), ProtocolType::InteractiveSign)
            | (MessageType::Sign(_), ProtocolType::InteractiveSign) => {}
            _ => {
                error!(
                    "Message type did not match type of this participant: got {:?}, expected {:?}",
                    message.message_type(),
                    P::protocol_type()
                );
                Err(CallerError::WrongProtocol)?
            }
        };

        // Check recipient
        if message.to() != self.id {
            Err(CallerError::WrongMessageRecipient)?
        }

        // Check that message is from a participant in this session
        if !self
            .participant
            .all_participants()
            .contains(&message.from())
        {
            Err(CallerError::InvalidMessageSender)?
        }

        // Handle it!
        let outcome = self.participant.process_message(rng, message)?;
        let (output, messages) = outcome.into_parts();
        Ok((output, messages))
    }

    /// Produce a message to signal to this participant that the protocol can
    /// begin.
    #[instrument(skip_all)]
    pub fn initialize_message(&self) -> Result<Message> {
        info!("Initializing subprotocol.");
        let empty: [u8; 0] = [];
        Message::new(P::ready_type(), self.sid(), self.id, self.id, &empty)
    }

    /// Return the protocol status.
    pub fn status(&self) -> &Status {
        self.participant.status()
    }
}

pub(crate) mod participant_config {
    use super::*;

    /// The configuration for the participant.
    ///
    /// Contains a set of at least two unique participant identifiers.
    #[derive(Debug, Clone, Serialize, Deserialize)]
    pub struct ParticipantConfig {
        /// The identifier for this participant.
        id: ParticipantIdentifier,
        /// The identifier for the other participants executing the protocol.
        other_ids: Vec<ParticipantIdentifier>,
    }

    impl ParticipantConfig {
        /// Get the [`ParticipantIdentifier`] for the owner of this config.
        pub fn id(&self) -> ParticipantIdentifier {
            self.id
        }

        /// Get the [`ParticipantIdentifier`] for all other participants.
        pub fn other_ids(&self) -> &[ParticipantIdentifier] {
            self.other_ids.as_slice()
        }

        /// Returns a list of all participant IDs, including `self`'s.
        pub fn all_participants(&self) -> Vec<ParticipantIdentifier> {
            let mut participant = self.other_ids().to_owned();
            participant.push(self.id());
            participant
        }

        /// Returns the total number of participants specified in the config
        /// (both other and self).
        pub fn count(&self) -> usize {
            self.other_ids.len() + 1
        }

        pub(crate) fn into_parts(self) -> (ParticipantIdentifier, Vec<ParticipantIdentifier>) {
            (self.id, self.other_ids)
        }

        /// Create a new [`ParticipantConfig`].
        ///
        /// The protocol requires at least two participants; `other_ids` cannot
        /// be empty. All participant identifiers must be unique.
        pub fn new(id: ParticipantIdentifier, other_ids: &[ParticipantIdentifier]) -> Result<Self> {
            if other_ids.is_empty() {
                error!(
                    "Tried to create a participant config with too few participants. There must be at least one `other_id`.",
                );
                Err(CallerError::ParticipantConfigError)?
            }

            // Test for uniqueness
            let unique_set =
                HashSet::<&ParticipantIdentifier>::from_iter(std::iter::once(&id).chain(other_ids));
            if unique_set.len() != other_ids.len() + 1 {
                error!(
                    "Tried to create a participant config with a non-unique set of participants"
                );
                Err(CallerError::ParticipantConfigError)?
            }

            Ok(Self {
                id,
                other_ids: other_ids.to_vec(),
            })
        }

        /// Returns a new [`ParticipantConfig`] including only the given
        /// participants.
        pub fn filter_participants(&self, pids: &[ParticipantIdentifier]) -> Self {
            let other_ids = self
                .other_ids()
                .iter()
                .filter(|pid| pids.contains(pid))
                .cloned()
                .collect();
            Self {
                id: self.id,
                other_ids,
            }
        }

        /// Get a list of `size` consistent [`ParticipantConfig`]s.
        ///
        /// Each config contains a different permutation of a single overall set
        /// of [`ParticipantIdentifier`]s.
        ///
        /// **⚠️ Security warning:** This method implies the existence of a
        /// trusted third party that generates the participant IDs. This
        /// method must not be used if your deployment does not have a
        /// trusted party.
        pub fn random_quorum<R: RngCore + CryptoRng>(
            size: usize,
            rng: &mut R,
        ) -> Result<Vec<ParticipantConfig>> {
            if size < 2 {
                Err(CallerError::ParticipantConfigError)?
            }
            let ids = std::iter::repeat_with(|| ParticipantIdentifier::random(rng))
                .take(size)
                .collect::<Vec<_>>();

            (0..size)
                .map(|i| {
                    let mut other_ids = ids.clone();
                    let id = other_ids.swap_remove(i);
                    Self::new(id, other_ids.as_slice())
                })
                .collect::<Result<_>>()
        }

        ///Create a random [`ParticipantConfig`].
        #[cfg(test)]
        pub(crate) fn random<R: RngCore + CryptoRng>(
            size: usize,
            rng: &mut R,
        ) -> ParticipantConfig {
            assert!(size > 1);
            let other_ids = std::iter::repeat_with(|| ParticipantIdentifier::random(rng))
                .take(size - 1)
                .collect::<Vec<_>>();
            let id = ParticipantIdentifier::random(rng);
            Self { id, other_ids }
        }

        /// Remove id from ParticipantConfig
        pub fn remove(&self) -> Result<Vec<ParticipantConfig>> {
            assert!(self.other_ids.len() > 1);
            let other_ids = self.other_ids();
            // for each element in other_ids, create a new ParticipantConfig
            // with that element as the id
            other_ids
                .iter()
                .enumerate()
                .map(|(i, id)| {
                    let mut others = other_ids.to_vec();
                    let _removed = others.swap_remove(i);
                    Self::new(*id, &others[..])
                })
                .collect::<Result<Vec<ParticipantConfig>>>()
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;
        use crate::utils::testing::init_testing;

        #[test]
        fn participant_config_must_have_at_least_two_participants() {
            let mut rng = init_testing();
            let result = ParticipantConfig::new(ParticipantIdentifier::random(&mut rng), &[]);
            assert!(result.is_err());
            assert_eq!(
                result.unwrap_err(),
                InternalError::CallingApplicationMistake(CallerError::ParticipantConfigError)
            );
        }

        #[test]
        fn participant_config_must_have_unique_participants() {
            let mut rng = init_testing();
            let id = ParticipantIdentifier::random(&mut rng);
            let result = ParticipantConfig::new(id, &[id]);
            assert!(result.is_err());
            assert_eq!(
                result.unwrap_err(),
                InternalError::CallingApplicationMistake(CallerError::ParticipantConfigError)
            );

            let result = ParticipantConfig::new(ParticipantIdentifier::random(&mut rng), &[id, id]);
            assert!(result.is_err());
            assert_eq!(
                result.unwrap_err(),
                InternalError::CallingApplicationMistake(CallerError::ParticipantConfigError)
            );
        }

        // Testing whether Participant Config has at least 2 participants
        #[test]
        fn random_quorum_must_have_at_least_two_participants() {
            let mut rng = init_testing();
            for i in 0..2 {
                let result = ParticipantConfig::random_quorum(i, &mut rng);
                assert!(result.is_err());
                assert_eq!(
                    result.unwrap_err(),
                    InternalError::CallingApplicationMistake(CallerError::ParticipantConfigError)
                );
            }
        }
    }
}

/// An identifier for a [`Participant`].
///
/// All [`Participant`]s in a sub-protocol must agree on the
/// [`ParticipantIdentifier`]s. That is, these are not local identifiers
/// controlled by a single `Participant`; they are unique, agreed-upon
/// identifiers for *all* the `Participant`s executing a sub-protocol. Each
/// member participating in a sub-protocol should have a different
/// `ParticipantIdentifier`.
///
/// The set of [`ParticipantIdentifier`]s are forever associated with a key and
/// must remain the same throughout all (sub-protocol) operations on that key.
/// For example, if a set of participants run keygen, aux-info, and then compute
/// several signatures, they must use the same set of identifiers throughout.
///
/// These `ParticipantIdentifier`s are embedded in the output
/// of our key operations. For example: this library will check the expected
/// `ParticipantIdentifier` from the aux-info output against the
/// `ParticipantIdentifier` of the `Participant` object executing the
/// sub-protocol. An error will be returned if they don't match. It is up to the
/// calling application to remember and use the expected `ParticipantIdentifier`
/// when executing sub-protocols.
///
/// A single `ParticipantIdentifier` should not be used
/// to represent different participants (even in different sub-protocols with
/// non-overlapping participant sets!).
///
/// `ParticipantIdentifier`s should be unique within a deployment, but they
/// don't necessarily have to be globally unique. `ParticipantIdentifier`s may
/// be re-used to execute multiple, unrelated, tss-ecdsa sub-protocols.
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Serialize, Deserialize)]
pub struct ParticipantIdentifier(u128);

impl ParticipantIdentifier {
    /// Generates a random [`ParticipantIdentifier`].
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        // Sample random 32 bytes and convert to hex
        let random_bytes = rng.gen::<u128>();
        let pid = Self(random_bytes);
        trace!("Created new {}", pid);
        pid
    }

    /// Note: This method is for convenience only. The `id` value is still
    /// expected to be generated from a cryptographically secure generator,
    /// for example [`Self::random`].
    pub fn from_u128(id: u128) -> Self {
        Self(id)
    }

    /// Get the ID as a number.
    pub fn as_u128(&self) -> u128 {
        self.0
    }
}

/// The `SharedContext` contains fixed known parameters across the entire
/// protocol. It does not however contain the entire protocol context.
#[derive(Debug, Clone)]
pub(crate) struct SharedContext<C> {
    sid: Identifier,
    participants: Vec<ParticipantIdentifier>,
    generator: C,
    order: BigNumber,
}

impl<C: CurveTrait> ProofContext for SharedContext<C> {
    fn as_bytes(&self) -> Result<Vec<u8>> {
        Ok([
            self.sid.0.to_be_bytes().into_iter().collect(),
            self.participants
                .iter()
                .flat_map(|pid| pid.0.to_le_bytes())
                .collect(),
            bincode::serialize(&self.generator)
                .map_err(|_| InternalError::InternalInvariantFailed)?,
            self.order.to_bytes(),
        ]
        .concat())
    }
}

impl<C: CurveTrait> SharedContext<C> {
    /// This function should not be used outside of the tests.
    #[cfg(test)]
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        let sid = Identifier::random(rng);
        let participant = ParticipantIdentifier::random(rng);
        let participant2 = ParticipantIdentifier::random(rng);
        let participants = vec![participant, participant2];
        let generator = C::GENERATOR;
        let order = C::order();
        SharedContext {
            sid,
            participants,
            generator,
            order,
        }
    }

    pub(crate) fn collect<P: InnerProtocolParticipant>(p: &P) -> Self {
        let mut participants = p.all_participants();
        participants.sort();
        let generator = C::GENERATOR;
        let order = C::order();
        SharedContext {
            sid: p.sid(),
            participants,
            generator,
            order,
        }
    }
    #[cfg(test)]
    pub fn fill_context(mut participants: Vec<ParticipantIdentifier>, sid: Identifier) -> Self {
        participants.sort();
        SharedContext {
            sid,
            participants,
            generator: C::GENERATOR,
            order: C::order(),
        }
    }
}

impl std::fmt::Display for ParticipantIdentifier {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        // 16 byte number. Take last five bytes for display purposes.
        let last_bytes = &self.0.to_be_bytes()[11..];
        write!(f, "ParticipantId(0x{})", hex::encode(last_bytes))
    }
}

#[derive(Copy, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
/// A session [`Identifier`] uniquely identifies a single
/// instance of a sub-protocol and all messages associated with it.
///
/// Session identifiers have two roles in the protocol: they tag messages
/// and they are incorporated as context into zero-knowledge proofs.
/// They must be _globally unique_; this allows participants to distinguish
/// messages belonging to different, concurrent sub-protocol runs,
/// prevents collisions between messages belonging to
/// different sessions, and prevents replay attacks by associating messages and
/// zero-knowledge proofs
/// with the session, fixed parameters, and previous subprotocols to which
/// they correspond. Global uniqueness is required in order to achieve
/// universally-composable (UC) security, the paradigm used by the paper to
/// prove security of the protocol.
///
/// 🔒 It is the responsibility of the calling application to pick session
/// identifiers. The calling application must select a protocol with
/// appropriate trust assumptions for its deployment to ensure the chosen
/// [`Identifier`] is unique and that all parties have the same one.
/// Sample protocols (with varying trust models!) could include:
/// - A trusted party randomly samples a unique identifier with
///   `Identifier::random()` and sends it to all parties;
/// - The participants run a Byzantine agreement protocol.
///
/// # Discrepancies with the paper with respect to session identifiers:
/// The paper defines session identifiers, denoted `sid` and `ssid`, somewhat
/// differently that we implement them in this codebase. We believe the
/// implementation achieves the same guarantees that the paper describes.
///
/// 1. The paper incorporates many types of data into its session and
/// sub-session identifiers, including fixed parameters, the participant set,
/// and key- and party-specific parameters that the calling application
/// persists[^outs]; these identifiers are used both to tag
/// messages and incorporate context into proofs. The codebase defines a single
/// `Identifier` type; this is a global, unique identifier
/// used to tag messages. The other fields (as well as
/// the `Identifier`) are incorporated into proofs using a different mechanism
/// to define the proof context.
///
/// 2. The paper distinguishes between identifiers for sessions (keygen) and
/// sub-sessions (auxinfo and presign)[^bug].
/// The codebase requires the calling application to select a new, unique
/// session [`Identifier`]s at three points:
/// (1) immediately before starting a new keygen session;
/// (2) immediately before starting a new auxinfo session;
/// (3) immediately before starting a new presigning session (for use in
/// presigning and the subsequent signature).
///
///
/// 3. 🔒 In the paper, `ssid` is updated each time the participants run the
/// key-refresh subprotocol.
/// The codebase relies on the calling application to generate a new, unique
/// `Identifier` for each new session.
///
/// [^outs]: These can include public key shares and shared randomness that were
/// returned as output from a previous run of keygen and public commitment
/// parameters that were returned as output from a previous run of auxinfo.
///
/// [^bug]: In fact, we think there is a minor bug in Figure 6 of the paper, since
/// the definition of `ssid` includes outputs of auxinfo, and thus cannot be
/// passed as input to auxinfo. We believe the correct instantiation of the
/// `ssid` for auxinfo is in Figure 3, which includes fixed parameters (`sid`)
/// and outputs from keygen, but _not_ outputs from auxinfo.
pub struct Identifier(u128);

impl Debug for Identifier {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Id({})", hex::encode(&self.0.to_le_bytes()[..4]))
    }
}

impl Identifier {
    /// Produces an [`Identifier`] chosen uniformly at random.
    ///
    /// **⚠️ Security warning:** This method implies the existence of a trusted
    /// third party that generates session IDs and correctly distributes
    /// them to all participants. This method must not be used if your
    /// deployment does not have a trusted party.
    #[instrument(skip_all)]
    pub fn random<R: RngCore + CryptoRng>(rng: &mut R) -> Self {
        // Sample random 32 bytes and convert to hex
        let random_bytes = rng.gen::<u128>();
        trace!("Created new Session Identifier({random_bytes})");
        Self(random_bytes)
    }
}

impl From<u128> for Identifier {
    fn from(value: u128) -> Self {
        Self(value)
    }
}

impl std::fmt::Display for Identifier {
    fn fmt(&self, f: &mut Formatter) -> std::fmt::Result {
        write!(f, "Id({})", hex::encode(&self.0.to_be_bytes()[..4]))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{
        auxinfo::{self, AuxInfoParticipant, AuxInfoPublic},
        curve::{ScalarTrait, TestCurve, VerifyingKeyTrait},
        k256::K256,
        keygen::{KeySharePublic, KeygenParticipant},
        messages,
        p256::P256,
        participant::Status,
        presign,
        sign::{self, InteractiveSignParticipant, SignParticipant},
        slip0010::{self, ckd::CKDInput},
        tshare::{self, tests::convert_to_t_out_of_t_shares, CoeffPrivate, TshareParticipant},
        utils::testing::init_testing,
        PresignParticipant,
    };
    use core::panic;
    use rand::{rngs::StdRng, seq::IteratorRandom};
    use sha3::{Digest, Keccak256};
    use std::{collections::HashMap, vec};
    use tracing::debug;

    // Negative test checking whether the message has the correct session id
    #[test]
    fn participant_rejects_messages_with_wrong_session_id() -> Result<()> {
        let mut rng = init_testing();
        let QUORUM_SIZE = 3;

        // Set up a single valid participant
        let config = ParticipantConfig::random(QUORUM_SIZE, &mut rng);
        let auxinfo_sid = Identifier::random(&mut rng);
        let mut participant =
            Participant::<AuxInfoParticipant<TestCurve>>::from_config(config, auxinfo_sid, ())
                .unwrap();

        // Make a message with the wrong session ID
        let message = participant.initialize_message()?;
        let bad_sid = Identifier::random(&mut rng);
        assert_ne!(bad_sid, message.id());
        let bad_sid_message = Message::new(
            message.message_type,
            bad_sid,
            message.from(),
            message.to(),
            &message.unverified_bytes,
        )?;

        // Make sure the participant rejects the message
        let result = participant.process_single_message(&bad_sid_message, &mut rng);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            InternalError::CallingApplicationMistake(CallerError::WrongSessionId)
        );
        Ok(())
    }

    // Negative test checking whether the message has the correct recipient
    // participant
    #[test]
    fn participant_rejects_messages_with_wrong_participant_to_field() -> Result<()> {
        let mut rng = init_testing();
        let QUORUM_SIZE = 3;

        // Set up a single valid participant
        let config = ParticipantConfig::random(QUORUM_SIZE, &mut rng);
        let auxinfo_sid = Identifier::random(&mut rng);
        let mut participant =
            Participant::<AuxInfoParticipant<TestCurve>>::from_config(config, auxinfo_sid, ())
                .unwrap();

        // Make a message with the wrong participant to field
        let message = participant.initialize_message()?;
        let bad_receiver_pid = ParticipantIdentifier::random(&mut rng);
        assert_ne!(participant.id(), bad_receiver_pid);
        let bad_receiver_pid_message = Message::new(
            message.message_type,
            message.id(),
            message.from(),
            bad_receiver_pid,
            &message.unverified_bytes,
        )?;

        // Make sure the participant rejects the message
        let result = participant.process_single_message(&bad_receiver_pid_message, &mut rng);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            InternalError::CallingApplicationMistake(CallerError::WrongMessageRecipient)
        );
        Ok(())
    }

    // Negative test checking whether the message has the correct protocol type
    #[test]
    fn participant_rejects_messages_with_wrong_protocol_type() -> Result<()> {
        let mut rng = init_testing();
        let QUORUM_SIZE = 3;

        // Set up a single valid participant
        let config = ParticipantConfig::random(QUORUM_SIZE, &mut rng);
        let auxinfo_sid = Identifier::random(&mut rng);
        let mut participant =
            Participant::<AuxInfoParticipant<TestCurve>>::from_config(config, auxinfo_sid, ())
                .unwrap();

        // Make a message with the wrong protocol type
        let message = participant.initialize_message()?;
        let bad_message_type =
            MessageType::Keygen(crate::messages::KeygenMessageType::R1CommitHash);
        let bad_protocol_type_message = Message::new(
            bad_message_type,
            message.id(),
            message.from(),
            message.to(),
            &message.unverified_bytes,
        )?;

        // Make sure the participant rejects the message
        let result = participant.process_single_message(&bad_protocol_type_message, &mut rng);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            InternalError::CallingApplicationMistake(CallerError::WrongProtocol)
        );
        Ok(())
    }

    // Negative test checking whether the message sender is included in the list of
    // all participants
    #[test]
    fn participant_rejects_messages_with_wrong_sender_participant() -> Result<()> {
        let mut rng = init_testing();
        let QUORUM_SIZE = 3;

        // Set up a single valid participant
        let config = ParticipantConfig::random(QUORUM_SIZE, &mut rng);
        let auxinfo_sid = Identifier::random(&mut rng);
        let mut participant =
            Participant::<AuxInfoParticipant<TestCurve>>::from_config(config, auxinfo_sid, ())
                .unwrap();

        //message with the wrong sender participant
        let message = participant.initialize_message()?;
        let bad_sender_pid = ParticipantIdentifier::random(&mut rng);
        let bad_sender_pid_message = Message::new(
            message.message_type(),
            message.id(),
            bad_sender_pid,
            message.to(),
            &message.unverified_bytes,
        )?;

        // Make sure the participant rejects the message
        let result = participant.process_single_message(&bad_sender_pid_message, &mut rng);
        assert!(result.is_err());
        assert_eq!(
            result.unwrap_err(),
            InternalError::CallingApplicationMistake(CallerError::InvalidMessageSender)
        );
        Ok(())
    }

    /// Delivers all messages into their respective participant's inboxes   
    fn deliver_all(
        messages: &[Message],
        inboxes: &mut HashMap<ParticipantIdentifier, Vec<Message>>,
    ) {
        for message in messages {
            inboxes
                .get_mut(&message.to())
                .unwrap()
                .push(message.clone());
        }
    }

    fn process_random_message<R: RngCore + CryptoRng, P: ProtocolParticipant>(
        quorum: &mut [Participant<P>],
        inboxes: &mut HashMap<ParticipantIdentifier, Vec<Message>>,
        rng: &mut R,
    ) -> Result<Option<(ParticipantIdentifier, P::Output)>> {
        if inboxes_are_empty(inboxes) {
            panic!("No more messages but the protocol isn't done!")
        }

        // Pick a random participant to process
        let participant = quorum.iter_mut().choose(rng).unwrap();

        let inbox: &mut Vec<Message> = inboxes.get_mut(&participant.id).unwrap();
        if inbox.is_empty() {
            // No messages to process for this participant, so pick another participant
            return Ok(None);
        }

        // Process a random message in the participant's inbox
        // This is done to simulate arbitrary message arrival ordering
        let index = rng.gen_range(0..inbox.len());
        let message = inbox.remove(index);
        debug!(
            "message from {} to {}, with type: {:?}",
            &message.from(),
            &participant.id,
            &message.message_type(),
        );
        let (output, messages) = participant.process_single_message(&message, rng)?;
        deliver_all(&messages, inboxes);

        // Return the (id, output) pair, so the calling application knows _who_
        // finished.
        Ok(output.map(|out| (participant.id, out)))
    }

    fn inboxes_are_empty(inboxes: &HashMap<ParticipantIdentifier, Vec<Message>>) -> bool {
        inboxes.iter().all(|(_pid, messages)| messages.is_empty())
    }

    #[test]
    fn test_basic_noninteractive_signing_works() {
        assert!(basic_noninteractive_signing_works::<K256>(3).is_ok());
        assert!(basic_noninteractive_signing_works::<P256>(3).is_ok());
    }

    #[test]
    fn test_hd_wallet_noninteractive_signing_works() {
        assert!(hd_wallet_noninteractive_signing_works(3, 42).is_ok());
    }

    #[cfg_attr(feature = "flame_it", flame)]
    #[test]
    fn test_basic_noninteractive_signing_works_with_keygen() {
        assert!(basic_noninteractive_threshold_signing_works::<K256>(3, 3, 3).is_ok());
        assert!(basic_noninteractive_threshold_signing_works::<K256>(3, 2, 3).is_ok());
        assert!(basic_noninteractive_threshold_signing_works::<K256>(2, 2, 3).is_ok());
        assert!(basic_noninteractive_threshold_signing_works::<P256>(3, 3, 3).is_ok());
        assert!(basic_noninteractive_threshold_signing_works::<P256>(3, 2, 3).is_ok());
        assert!(basic_noninteractive_threshold_signing_works::<P256>(2, 2, 3).is_ok());
    }

    #[ignore]
    #[test]
    fn test_full_noninteractive_signing_works_with_hd_wallet_larger_values() {
        assert!(full_noninteractive_threshold_signing_works(5, 5, 5, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(5, 4, 5, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(4, 4, 5, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(5, 3, 5, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(4, 3, 5, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(3, 3, 5, 42).is_ok());
    }

    #[cfg_attr(feature = "flame_it", flame)]
    #[test]
    fn test_full_noninteractive_signing_works_with_hd_wallet() {
        assert!(full_noninteractive_threshold_signing_works(3, 3, 3, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(3, 2, 3, 42).is_ok());
        assert!(full_noninteractive_threshold_signing_works(2, 2, 3, 42).is_ok());
        // 2**31
        let invalid_index = 1 << 31;
        assert!(full_noninteractive_threshold_signing_works(3, 3, 3, invalid_index).is_err());
    }

    #[ignore]
    #[test]
    fn test_full_noninteractive_signing_works_with_hd_wallet_err_larger_values() {
        assert!(full_noninteractive_threshold_signing_works(3, 4, 5, 42).is_err());
        assert!(full_noninteractive_threshold_signing_works(2, 4, 5, 42).is_err());
    }

    #[test]
    fn test_full_noninteractive_signing_works_with_hd_wallet_err() {
        assert!(full_noninteractive_threshold_signing_works(2, 3, 4, 42).is_err());
    }

    pub struct AuxInfoHelperOutput<C: CurveTrait> {
        auxinfo_outputs:
            HashMap<ParticipantIdentifier, <AuxInfoParticipant<C> as ProtocolParticipant>::Output>,
        inboxes: HashMap<ParticipantIdentifier, Vec<Message>>,
    }

    // Receive as input a vector of configs and return a struct containing
    // the auxinfo outputs and the inboxes
    pub fn auxinfo_helper<C: CurveTrait>(
        configs: Vec<ParticipantConfig>,
        mut rng: StdRng,
    ) -> Result<AuxInfoHelperOutput<C>> {
        let QUORUM_SIZE = configs.len();
        // Set up auxinfo participants
        let auxinfo_sid = Identifier::random(&mut rng);
        let mut auxinfo_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                Participant::<AuxInfoParticipant<C>>::from_config(config, auxinfo_sid, ()).unwrap()
            })
            .collect::<Vec<_>>();

        let mut inboxes = HashMap::from_iter(
            auxinfo_quorum
                .iter()
                .map(|p| (p.id, vec![]))
                .collect::<Vec<_>>(),
        );

        let mut auxinfo_outputs: HashMap<
            ParticipantIdentifier,
            <AuxInfoParticipant<TestCurve> as ProtocolParticipant>::Output,
        > = HashMap::new();

        // Initialize auxinfo for all parties
        for participant in &auxinfo_quorum {
            let inbox: &mut Vec<Message> = inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        // Run auxinfo until all parties have outputs
        while auxinfo_outputs.len() < QUORUM_SIZE {
            let output = process_random_message(&mut auxinfo_quorum, &mut inboxes, &mut rng)?;

            if let Some((pid, output)) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(auxinfo_outputs.insert(pid, output).is_none());
            }
        }

        // Auxinfo is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(&inboxes));
        // And make sure all participants have successfully terminated.
        assert!(auxinfo_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        Ok(AuxInfoHelperOutput {
            auxinfo_outputs,
            inboxes,
        })
    }

    pub struct KeygenHelperOutput<C: CurveTrait> {
        keygen_outputs:
            HashMap<ParticipantIdentifier, <KeygenParticipant<C> as ProtocolParticipant>::Output>,
    }

    // Receive as input a vector of configs and the inboxes from auxinfo_helper
    // It returns a struct containing and the keygen outputs
    pub fn keygen_helper<C: CurveTrait>(
        configs: Vec<ParticipantConfig>,
        mut inboxes: HashMap<ParticipantIdentifier, Vec<Message>>,
        mut rng: StdRng,
    ) -> Result<KeygenHelperOutput<C>> {
        let QUORUM_SIZE = configs.len();
        // Set up keygen participants
        let keygen_sid = Identifier::random(&mut rng);
        let mut keygen_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                Participant::<KeygenParticipant<C>>::from_config(config, keygen_sid, ()).unwrap()
            })
            .collect::<Vec<_>>();

        let mut keygen_outputs: HashMap<
            ParticipantIdentifier,
            <KeygenParticipant<C> as ProtocolParticipant>::Output,
        > = HashMap::new();

        // Initialize keygen for all participants
        for participant in &keygen_quorum {
            let inbox: &mut std::vec::Vec<messages::Message> =
                inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        // Run keygen until all parties have outputs
        while keygen_outputs.len() < QUORUM_SIZE {
            let output = process_random_message(&mut keygen_quorum, &mut inboxes, &mut rng)?;

            if let Some((pid, output)) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(keygen_outputs.insert(pid, output).is_none());
            }
        }

        // Keygen is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(&inboxes));
        // And make sure all participants have successfully terminated.
        assert!(keygen_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        Ok(KeygenHelperOutput { keygen_outputs })
    }

    pub struct TshareHelperOutput<C: CurveTrait> {
        tshare_inputs: Vec<tshare::Input<C>>,
        tshare_outputs:
            HashMap<ParticipantIdentifier, <TshareParticipant<C> as ProtocolParticipant>::Output>,
    }
    // Receive as input a vector of configs, the child_index, the auxinfo outputs
    // and the keygen outputs It returns a struct containing and the tshare
    // outputs.
    pub fn tshare_helper<C: CurveTrait>(
        configs: Vec<ParticipantConfig>,
        auxinfo_outputs: HashMap<
            ParticipantIdentifier,
            <AuxInfoParticipant<C> as ProtocolParticipant>::Output,
        >,
        threshold: usize,
        mut rng: StdRng,
    ) -> Result<TshareHelperOutput<C>> {
        let QUORUM_SIZE = configs.len();
        // Set up Tshare participants
        let tshare_sid = Identifier::random(&mut rng);
        let tshare_inputs = configs
            .iter()
            .map(|config| {
                let auxinfo_output = auxinfo_outputs.get(&config.id()).unwrap();
                let secret = C::Scalar::random();
                tshare::Input::new(
                    auxinfo_output.clone(),
                    Some(CoeffPrivate { x: secret }),
                    threshold,
                )
                .unwrap()
            })
            .collect::<Vec<_>>();

        let mut tshare_quorum = configs
            .clone()
            .into_iter()
            .zip(tshare_inputs.clone())
            .map(|(config, input)| {
                Participant::<TshareParticipant<C>>::from_config(config, tshare_sid, input).unwrap()
            })
            .collect::<Vec<_>>();
        let mut tshare_outputs: HashMap<
            ParticipantIdentifier,
            <TshareParticipant<C> as ProtocolParticipant>::Output,
        > = HashMap::new();

        let mut inboxes = HashMap::from_iter(
            tshare_quorum
                .iter()
                .map(|p| (p.id, vec![]))
                .collect::<Vec<_>>(),
        );

        for participant in &mut tshare_quorum {
            let inbox = inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        while tshare_outputs.len() < QUORUM_SIZE {
            let output = process_random_message(&mut tshare_quorum, &mut inboxes, &mut rng)?;

            if let Some((pid, output)) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(tshare_outputs.insert(pid, output).is_none());
            }
        }

        // Tshare is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(&inboxes));
        // And make sure all participants have successfully terminated.
        assert!(tshare_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        Ok(TshareHelperOutput {
            tshare_inputs,
            tshare_outputs,
        })
    }

    // Receives as input the auxinfo outputs and the keygen outputs
    // Returns the presign outputs
    pub fn presign_helper<C: CurveTrait>(
        configs: Vec<ParticipantConfig>,
        mut auxinfo_outputs: HashMap<
            ParticipantIdentifier,
            <AuxInfoParticipant<C> as ProtocolParticipant>::Output,
        >,
        mut keygen_outputs: HashMap<
            ParticipantIdentifier,
            <KeygenParticipant<C> as ProtocolParticipant>::Output,
        >,
        inboxes: &mut HashMap<ParticipantIdentifier, Vec<Message>>,
        mut rng: StdRng,
    ) -> Result<
        HashMap<ParticipantIdentifier, <PresignParticipant<C> as ProtocolParticipant>::Output>,
    > {
        let QUORUM_REAL = auxinfo_outputs.len();

        let presign_sid = Identifier::random(&mut rng);

        // Prepare presign inputs: a pair of outputs from keygen and auxinfo.
        let presign_inputs = configs
            .iter()
            .map(|config| {
                (
                    auxinfo_outputs.remove(&config.id()).unwrap(),
                    keygen_outputs.remove(&config.id()).unwrap(),
                )
            })
            .map(|(auxinfo_output, keygen_output)| {
                presign::Input::new(auxinfo_output, keygen_output).unwrap()
            })
            .collect::<Vec<_>>();

        let mut presign_quorum = configs
            .clone()
            .into_iter()
            .zip(presign_inputs)
            .map(|(config, input)| {
                Participant::<PresignParticipant<C>>::from_config(config, presign_sid, input)
                    .unwrap()
            })
            .collect::<Vec<_>>();
        let mut presign_outputs: HashMap<
            ParticipantIdentifier,
            <PresignParticipant<C> as ProtocolParticipant>::Output,
        > = HashMap::new();

        for participant in &mut presign_quorum {
            let inbox = inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        while presign_outputs.len() < QUORUM_REAL {
            let output = process_random_message(&mut presign_quorum, inboxes, &mut rng)?;

            if let Some((pid, output)) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(presign_outputs.insert(pid, output).is_none());
            }
        }

        // Presigning is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(inboxes));
        // And make sure all participants have successfully terminated.
        assert!(presign_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        Ok(presign_outputs)
    }

    pub struct SignHelperInput<C: CurveTrait> {
        chain_code: [u8; 32],
        presign_outputs:
            HashMap<ParticipantIdentifier, <PresignParticipant<C> as ProtocolParticipant>::Output>,
        public_key_shares: Vec<KeySharePublic<C>>,
        saved_public_key: C::VerifyingKey,
        child_index: u32,
        threshold: usize,
        inboxes: HashMap<ParticipantIdentifier, Vec<Message>>,
    }

    // Sign helper receives as input the configs and a special struct containg
    // all the information needed for signature generation.
    // INFO: this function is used to test the full non-interactive signing protocol
    pub fn sign_helper<C: CurveTrait>(
        configs: Vec<ParticipantConfig>,
        sign_helper_input: SignHelperInput<C>,
        mut rng: StdRng,
    ) -> Result<bool> {
        let message = b"Testing full protocol execution with non-interactive signing protocol";
        let QUORUM_REAL = configs.len();
        let digest = Keccak256::new_with_prefix(message);
        let sign_sid = Identifier::random(&mut rng);

        let mut presign_outputs = sign_helper_input.presign_outputs;
        let public_key_shares = sign_helper_input.public_key_shares;
        let saved_public_key = sign_helper_input.saved_public_key;
        let threshold = sign_helper_input.threshold;
        let mut inboxes = sign_helper_input.inboxes;

        // Make signing participants
        let mut sign_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                let record = presign_outputs.remove(&config.id()).unwrap();
                let input =
                    sign::Input::new(message, record, public_key_shares.clone(), threshold, None);
                Participant::<SignParticipant<C>>::from_config(config, sign_sid, input)
            })
            .collect::<Result<Vec<_>>>()?;

        // Prepare output storage and initial "ready" messages
        let mut sign_outputs = Vec::with_capacity(QUORUM_REAL);
        for participant in &mut sign_quorum {
            let inbox = inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        // Run signing protocol
        while sign_outputs.len() < QUORUM_REAL {
            let output = process_random_message(&mut sign_quorum, &mut inboxes, &mut rng)?;

            if let Some((_pid, output)) = output {
                sign_outputs.push(output);
            }
        }

        // Signing is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(&inboxes));
        // And make sure all participants have successfully terminated.
        assert!(sign_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        // Validate output: everyone should get the same signature...
        assert!(sign_outputs.windows(2).all(|sig| sig[0] == sig[1]));

        // get the first participant and then call shifted_public_key
        assert!(saved_public_key
            .verify_signature(digest, sign_outputs[0])
            .is_ok());

        Ok(true)
    }

    // Sign helper receives as input the configs and a special struct containg
    // all the information needed for signature generation.
    // INFO: this function is used to test the full non-interactive signing protocol
    pub fn sign_helper_hd_wallet(
        configs: Vec<ParticipantConfig>,
        sign_helper_input: SignHelperInput<K256>,
        mut rng: StdRng,
    ) -> Result<bool> {
        let message = b"Testing full protocol execution with non-interactive signing protocol";
        let QUORUM_REAL = configs.len();
        let digest = Keccak256::new_with_prefix(message);
        let sign_sid = Identifier::random(&mut rng);

        let mut presign_outputs = sign_helper_input.presign_outputs;
        let public_key_shares = sign_helper_input.public_key_shares;
        let saved_public_key = sign_helper_input.saved_public_key;
        let child_index = sign_helper_input.child_index;
        let threshold = sign_helper_input.threshold;
        let mut inboxes = sign_helper_input.inboxes;
        let chain_code = sign_helper_input.chain_code;

        let saved_public_key_bytes: Vec<u8> = saved_public_key.clone().to_sec1_bytes().to_vec();

        // if child_index is None, index is zero, otherwise it is child_index
        let index = child_index;

        let shift_input: CKDInput<K256> = slip0010::ckd::CKDInput::new(
            None,
            K256::try_from_bytes(&saved_public_key_bytes)?,
            chain_code,
            index,
        )?;
        let ckd_output = slip0010::ckd::CKDInput::derive_public_shift(&shift_input);
        let shift_scalar = ckd_output.private_key;

        // Make signing participants
        let mut sign_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                let record = presign_outputs.remove(&config.id()).unwrap();
                let input = sign::Input::new(
                    message,
                    record,
                    public_key_shares.clone(),
                    threshold,
                    Some(shift_scalar),
                );
                Participant::<SignParticipant<K256>>::from_config(config, sign_sid, input)
            })
            .collect::<Result<Vec<_>>>()?;

        // Prepare output storage and initial "ready" messages
        let mut sign_outputs = Vec::with_capacity(QUORUM_REAL);
        for participant in &mut sign_quorum {
            let inbox = inboxes.get_mut(&participant.id).unwrap();
            inbox.push(participant.initialize_message()?);
        }

        // Run signing protocol
        while sign_outputs.len() < QUORUM_REAL {
            let output = process_random_message(&mut sign_quorum, &mut inboxes, &mut rng)?;

            if let Some((_pid, output)) = output {
                sign_outputs.push(output);
            }
        }

        // Signing is done! Make sure there are no more messages.
        assert!(inboxes_are_empty(&inboxes));
        // And make sure all participants have successfully terminated.
        assert!(sign_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        // Validate output: everyone should get the same signature...
        assert!(sign_outputs.windows(2).all(|sig| sig[0] == sig[1]));

        // get the first participant and then call shifted_public_key
        let first_participant = sign_quorum.first().unwrap();
        let saved_shifted_public_key: <K256 as CurveTrait>::VerifyingKey = first_participant
            .participant
            .shifted_public_key(public_key_shares, shift_scalar)?;
        assert!(saved_shifted_public_key
            .verify_signature(digest, sign_outputs[0])
            .is_ok());

        Ok(true)
    }

    // When a threshold protocol is run, it is necessary to adjust the auxinfo
    // so that only the participants in the protocol are included in the
    // auxinfo outputs
    pub fn adjust_auxinfo(
        all_participants: &[ParticipantIdentifier],
        auxinfo_outputs: HashMap<ParticipantIdentifier, auxinfo::Output>,
    ) -> Result<HashMap<ParticipantIdentifier, auxinfo::Output>> {
        // Set up presign participants
        let mut auxinfo_outputs_presign = HashMap::new();

        // remove elements not in `all-participants` from auxinfo_outputs_presign
        for pid in auxinfo_outputs.keys() {
            if all_participants.contains(pid) {
                let output = auxinfo_outputs.get(pid).unwrap();
                let new_aux_pk: Vec<AuxInfoPublic> = output
                    .public_auxinfo()
                    .iter()
                    .filter(|auxinfo| all_participants.contains(&auxinfo.participant()))
                    .cloned()
                    .collect();
                let new_output =
                    auxinfo::Output::from_parts(new_aux_pk, output.private_auxinfo().clone())?;
                assert!(auxinfo_outputs_presign.insert(*pid, new_output).is_none());
            }
        }

        Ok(auxinfo_outputs_presign)
    }

    pub fn basic_noninteractive_signing_works<C: CurveTrait>(
        n: usize, // Total number of participants in the protocol
    ) -> Result<()> {
        let mut rng = init_testing();

        // Set GLOBAL config for participants
        let configs = ParticipantConfig::random_quorum(n, &mut rng).unwrap();

        // Call the auxinfo helper to run its subprotocol
        let auxinfo_helper_output = auxinfo_helper::<C>(configs.clone(), rng.clone())?;
        let auxinfo_outputs = auxinfo_helper_output.auxinfo_outputs;
        let mut inboxes = auxinfo_helper_output.inboxes;

        // Call the keygen helper to run its subprotocol
        let keygen_helper_output = keygen_helper(configs.clone(), inboxes.clone(), rng.clone())?;
        let keygen_outputs = keygen_helper_output.keygen_outputs;

        let first_keygen_output = keygen_outputs.get(&configs.first().unwrap().id()).unwrap();
        let public_key_shares = first_keygen_output.public_key_shares().to_vec();
        let saved_public_key = first_keygen_output.public_key()?;

        // Call the presign helper to run its subprotocol
        let presign_outputs = presign_helper(
            configs.clone(),
            auxinfo_outputs,
            keygen_outputs.clone(),
            &mut inboxes,
            rng.clone(),
        )?;

        let chain_code = *first_keygen_output.chain_code();

        let sign_helper_input = SignHelperInput::<C> {
            public_key_shares,
            saved_public_key,
            presign_outputs,
            chain_code,
            inboxes,
            child_index: 0,
            threshold: n,
        };

        // Call the sign helper to run its subprotocol
        assert!(sign_helper::<C>(configs, sign_helper_input, rng)?);

        Ok(())
    }

    fn hd_wallet_noninteractive_signing_works(
        n: usize, // Total number of participants in the protocol
        child_index: u32,
    ) -> Result<()> {
        let mut rng = init_testing();

        // Set GLOBAL config for participants
        let configs = ParticipantConfig::random_quorum(n, &mut rng).unwrap();

        // Call the auxinfo helper to run its subprotocol
        let auxinfo_helper_output = auxinfo_helper::<K256>(configs.clone(), rng.clone())?;
        let auxinfo_outputs = auxinfo_helper_output.auxinfo_outputs;
        let mut inboxes = auxinfo_helper_output.inboxes;

        // Call the keygen helper to run its subprotocol
        let keygen_helper_output = keygen_helper(configs.clone(), inboxes.clone(), rng.clone())?;
        let keygen_outputs = keygen_helper_output.keygen_outputs;

        let first_keygen_output = keygen_outputs.get(&configs.first().unwrap().id()).unwrap();
        let public_key_shares = first_keygen_output.public_key_shares().to_vec();
        let saved_public_key = first_keygen_output.public_key()?;

        // Call the presign helper to run its subprotocol
        let presign_outputs = presign_helper(
            configs.clone(),
            auxinfo_outputs,
            keygen_outputs.clone(),
            &mut inboxes,
            rng.clone(),
        )?;

        let chain_code = *first_keygen_output.chain_code();

        let sign_helper_input = SignHelperInput {
            public_key_shares,
            saved_public_key,
            presign_outputs,
            chain_code,
            inboxes,
            child_index,
            threshold: n,
        };

        // Call the sign helper to run its subprotocol
        assert!(sign_helper_hd_wallet(configs, sign_helper_input, rng)?);

        Ok(())
    }

    fn basic_noninteractive_threshold_signing_works<C: CurveTrait>(
        r: usize, // The real quorum size, which is the number of participants that will actually
        // participate in the protocol
        t: usize, // The minimum quorum allowed to complete the protocol
        n: usize, // Total number of participants in the protocol
    ) -> Result<()> {
        let mut rng = init_testing();

        // Set GLOBAL config for participants
        let mut configs = ParticipantConfig::random_quorum(n, &mut rng).unwrap();

        // Call the auxinfo helper to run its subprotocol
        let auxinfo_helper_output = auxinfo_helper::<C>(configs.clone(), rng.clone())?;
        let auxinfo_outputs = auxinfo_helper_output.auxinfo_outputs;
        let mut inboxes = auxinfo_helper_output.inboxes;

        // Call the tshare helper to run its subprotocol
        let tshare_helper_outputs =
            tshare_helper(configs.clone(), auxinfo_outputs.clone(), t, rng.clone())?;
        let tshare_outputs = tshare_helper_outputs.tshare_outputs;
        let tshare_inputs = tshare_helper_outputs.tshare_inputs;

        // remove n - r elements from the configs (the last ones)
        assert!((r > 1) && (n >= r));
        for _ in 0..(n - r) {
            configs = configs.clone().last().unwrap().remove().unwrap();
        }
        assert!(configs.len() == r);

        let all_participants = configs.first().unwrap().all_participants();

        // read rid from first output from tshare protocol
        let first_output = tshare_outputs.get(&configs.first().unwrap().id()).unwrap();
        let rid = first_output.rid();
        let chain_code = first_output.chain_code();

        // sum all tshare inputs such that we can compare with the sum of the tshare
        // outputs
        let sum_tshare_input = tshare_inputs
            .iter()
            .map(|input| input.share().unwrap().x)
            .fold(C::Scalar::zero(), |acc, x| acc + x);

        // t-out-of-t conversion
        let toft_keygen_outputs = convert_to_t_out_of_t_shares::<C>(
            tshare_outputs.clone(),
            all_participants.clone(),
            *rid,
            *chain_code,
            sum_tshare_input,
            t,
        )?;

        let first_keygen_output = toft_keygen_outputs
            .get(&configs.first().unwrap().id())
            .unwrap();
        let public_key_shares = first_keygen_output.public_key_shares().to_vec();
        let saved_public_key = first_keygen_output.public_key()?;

        let auxinfo_outputs_presign = adjust_auxinfo(&all_participants, auxinfo_outputs.clone())?;

        let presign_outputs = presign_helper(
            configs.clone(),
            auxinfo_outputs_presign,
            toft_keygen_outputs.clone(),
            &mut inboxes,
            rng.clone(),
        )?;

        let chain_code = *first_keygen_output.chain_code();

        let sign_helper_input = SignHelperInput::<C> {
            public_key_shares,
            saved_public_key,
            presign_outputs,
            chain_code,
            inboxes,
            child_index: 0,
            threshold: t,
        };

        // Call the sign helper to run its subprotocol
        assert!(sign_helper::<C>(configs, sign_helper_input, rng)?);

        Ok(())
    }

    // This function exercises both the Keygen and HD Wallet methods for
    // non-interactive signing. It generates a quorum of participants, runs the
    // auxinfo, keygen or HD wallet, tshare, presign, and sign protocols, and
    // verifies that the final signature is correct.
    fn full_noninteractive_threshold_signing_works(
        r: usize, // The real quorum size, which is the number of participants that will actually
        // participate in the protocol
        t: usize,         // The minimum quorum allowed to complete the protocol
        n: usize,         // Total number of participants in the protocol
        child_index: u32, // The child index for the HD wallet
    ) -> Result<()> {
        let mut rng = init_testing();

        // Set GLOBAL config for participants
        let mut configs = ParticipantConfig::random_quorum(n, &mut rng).unwrap();

        // Call the auxinfo helper to run its subprotocol
        let auxinfo_helper_output: AuxInfoHelperOutput<K256> =
            auxinfo_helper(configs.clone(), rng.clone())?;
        let auxinfo_outputs = auxinfo_helper_output.auxinfo_outputs;
        let mut inboxes = auxinfo_helper_output.inboxes;

        // Call the tshare helper to run its subprotocol
        let tshare_helper_outputs =
            tshare_helper(configs.clone(), auxinfo_outputs.clone(), t, rng.clone())?;
        let tshare_outputs = tshare_helper_outputs.tshare_outputs;
        let tshare_inputs = tshare_helper_outputs.tshare_inputs;

        // remove n - r elements from the configs (the last ones)
        assert!((r > 1) && (n >= r));
        for _ in 0..(n - r) {
            configs = configs.clone().last().unwrap().remove().unwrap();
        }
        assert!(configs.len() == r);

        let all_participants = configs.first().unwrap().all_participants();

        // read rid from first output from tshare protocol
        let first_output = tshare_outputs.get(&configs.first().unwrap().id()).unwrap();
        let rid = first_output.rid();
        let chain_code = first_output.chain_code();

        // sum all tshare inputs such that we can compare with the sum of the tshare
        // outputs
        let sum_tshare_input = tshare_inputs
            .iter()
            .map(|input| input.share().unwrap().x)
            .fold(k256::Scalar::ZERO, |acc, x| acc + x);

        // t-out-of-t conversion
        let toft_keygen_outputs = convert_to_t_out_of_t_shares(
            tshare_outputs.clone(),
            all_participants.clone(),
            *rid,
            *chain_code,
            sum_tshare_input,
            t,
        )?;

        let first_keygen_output = toft_keygen_outputs
            .get(&configs.first().unwrap().id())
            .unwrap();
        let public_key_shares = first_keygen_output.public_key_shares().to_vec();
        let saved_public_key = first_keygen_output.public_key()?;

        let auxinfo_outputs_presign = adjust_auxinfo(&all_participants, auxinfo_outputs.clone())?;

        let presign_outputs = presign_helper(
            configs.clone(),
            auxinfo_outputs_presign,
            toft_keygen_outputs.clone(),
            &mut inboxes,
            rng.clone(),
        )?;

        let chain_code = *first_keygen_output.chain_code();

        let sign_helper_input = SignHelperInput {
            public_key_shares,
            saved_public_key,
            presign_outputs,
            chain_code,
            inboxes,
            child_index,
            threshold: t,
        };

        // Call the sign helper to run its subprotocol
        assert!(sign_helper_hd_wallet(configs, sign_helper_input, rng)?);

        Ok(())
    }

    #[test]
    #[ignore]
    fn full_protocol_execution_with_interactive_signing_works() -> Result<()> {
        let rng = &mut init_testing();
        let QUORUM_SIZE = 4;
        // Set GLOBAL config for participants
        let configs = ParticipantConfig::random_quorum(QUORUM_SIZE, rng)?;
        let mut inboxes = Vec::new();

        // Set up keygen participants
        let keygen_sid = Identifier::random(rng);
        let mut keygen_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                Participant::<KeygenParticipant<TestCurve>>::from_config(config, keygen_sid, ())
                    .unwrap()
            })
            .collect::<Vec<_>>();
        let mut keygen_outputs: HashMap<
            ParticipantIdentifier,
            <KeygenParticipant<TestCurve> as ProtocolParticipant>::Output,
        > = HashMap::new();

        // Initialize keygen for all participants
        for participant in &keygen_quorum {
            inboxes.push(participant.initialize_message()?);
        }

        // Run keygen until all parties have outputs
        while keygen_outputs.len() < QUORUM_SIZE {
            assert!(
                !inboxes.is_empty(),
                "No more messages but we're not done with keygen"
            );

            // Pick a random message to process
            let message = inboxes.swap_remove(rng.gen_range(0..inboxes.len()));
            let participant = keygen_quorum
                .iter_mut()
                .find(|p| p.id() == message.to())
                .unwrap();
            let (output, messages) = participant.process_single_message(&message, rng)?;

            // Save any outgoing messages and the output
            inboxes.extend(messages);
            if let Some(output) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(keygen_outputs.insert(participant.id(), output).is_none());
            }
        }

        // Keygen is done! Make sure there are no more messages and that everyone
        // finished
        assert!(inboxes.is_empty());
        assert!(keygen_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        // Save the public key for later
        let saved_public_key = keygen_outputs[&configs[0].id()].public_key()?;

        // Set up auxinfo participants
        let auxinfo_sid = Identifier::random(rng);
        let mut auxinfo_quorum = configs
            .clone()
            .into_iter()
            .map(|config| {
                Participant::<AuxInfoParticipant<TestCurve>>::from_config(config, auxinfo_sid, ())
                    .unwrap()
            })
            .collect::<Vec<_>>();

        let mut auxinfo_outputs: HashMap<
            ParticipantIdentifier,
            <AuxInfoParticipant<TestCurve> as ProtocolParticipant>::Output,
        > = HashMap::new();

        // Initialize auxinfo for all parties
        for participant in &auxinfo_quorum {
            inboxes.push(participant.initialize_message()?);
        }

        // Run auxinfo until all parties have outputs
        while auxinfo_outputs.len() < QUORUM_SIZE {
            assert!(
                !inboxes.is_empty(),
                "No more messages but we're not done with auxinfo"
            );

            // Pick a random message to process
            let message = inboxes.swap_remove(rng.gen_range(0..inboxes.len()));
            let participant = auxinfo_quorum
                .iter_mut()
                .find(|p| p.id() == message.to())
                .unwrap();
            let (output, messages) = participant.process_single_message(&message, rng)?;

            // Save any outgoing messages and the output
            inboxes.extend(messages);
            if let Some(output) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                assert!(auxinfo_outputs.insert(participant.id(), output).is_none());
            }
        }

        // Auxinfo is done! Make sure there are no more messages.
        assert!(inboxes.is_empty());
        // And make sure all participants have successfully terminated.
        assert!(auxinfo_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        // Prepare inputs for sign
        let message = b"Signing a message to test full protocol execution with interactive sign";
        let digest = Keccak256::new_with_prefix(message);

        let sign_inputs = configs
            .iter()
            .map(|config| {
                (
                    auxinfo_outputs.remove(&config.id()).unwrap(),
                    keygen_outputs.remove(&config.id()).unwrap(),
                )
            })
            .map(|(auxinfo_output, keygen_output)| {
                sign::InteractiveInput::new(message, keygen_output, auxinfo_output)
            })
            .collect::<Result<Vec<_>>>()?;

        // Set up signing participants
        let sign_sid = Identifier::random(rng);
        let mut sign_quorum = std::iter::zip(configs, sign_inputs)
            .map(|(config, input)| {
                Participant::<InteractiveSignParticipant<TestCurve>>::from_config(
                    config, sign_sid, input,
                )
            })
            .collect::<Result<Vec<_>>>()?;

        let mut sign_outputs = Vec::new();

        // Initialize signing for all parties
        for participant in &sign_quorum {
            inboxes.push(participant.initialize_message()?);
        }

        // Run sign until all parties have outputs
        while sign_outputs.len() < QUORUM_SIZE {
            assert!(
                !inboxes.is_empty(),
                "No more messages but we're not done with signing"
            );

            // Pick a random message to process
            let message = inboxes.swap_remove(rng.gen_range(0..inboxes.len()));
            let participant = sign_quorum
                .iter_mut()
                .find(|p| p.id() == message.to())
                .unwrap();
            let (output, messages) = participant.process_single_message(&message, rng)?;

            // Save any outgoing messages and the output
            inboxes.extend(messages);
            if let Some(output) = output {
                // Save the output, and make sure this participant didn't already return an
                // output.
                sign_outputs.push(output);
            }
        }

        // Make sure all messages sent and every party finished
        assert!(inboxes.is_empty());
        assert!(sign_quorum
            .iter()
            .all(|p| *p.status() == Status::TerminatedSuccessfully));

        // Validate output: everyone should get the same signature...
        assert!(sign_outputs.windows(2).all(|sig| sig[0] == sig[1]));

        // ...and the signature should be valid under the public key we saved
        assert!(saved_public_key
            .verify_signature(digest, sign_outputs[0])
            .is_ok());

        Ok(())
    }
}
